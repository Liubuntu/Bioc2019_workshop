---
title: "BiocWorkshop2019_part2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BiocWorkshop2019}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Load R/Bioconductor packages

```{r setup}
library(GDSArray)
library(VCFArray)
library(DelayedDataFrame)
library(VariantExperiment)  ## depends on "DelayedDataFrame", and "GDSArray"
library(SQLDataFrame) ## depends on "dplyr", and "dbplyr"
library(VariantAnnotation)
library(BiocWorkshops2019)
```

# Extension of `DelayedArray` with GDS and VCF as "backend"
	
## GDSArray

### Quick look of Genomic Data Structure (GDS)

The _Bioconductor_ package `gdsfmt` has provided a high-level R
interface to CoreArray Genomic Data Structure (GDS) data files, which
is designed for large-scale datasets, especially for data which are
much larger than the available random-access memory.

The GDS format has been widely used in genetic/genomic research for
high-throughput genotyping or sequencing data. There are two major
classes that extends the `gds.class`: `SNPGDSFileClass` suited for
genotyping data (e.g., GWAS), and `SeqVarGDSClass` that are designed
specifically for DNA-sequencing data. The file format attribute in
each data class is set as `SNP_ARRAY` and `SEQ_ARRAY`. There are rich
functions written based on these data classes for common data
operation and statistical analysis.

More details about GDS format can be found in the vignettes of the
[gdsfmt][], [SNPRelate][], and [SeqArray][] packages.

[gdsfmt]: https://bioconductor.org/packages/gdsfmt
[SNPRelate]: https://bioconductor.org/packages/SNPRelate
[SeqArray]: https://bioconductor.org/packages/SeqArray

### `GDSArray`, `GDSMatrix`, and `GDSFile`

`GDSArray` represents GDS files as `DelayedArray` instances. It has
methods like `dim`, `dimnames` defined, and it inherits array-like
operations and methods from `DelayedArray`, e.g., the subsetting
method of `[`.

The `GDSArray()` constructor takes as arguments the file path and the
GDS node inside the GDS file. The `GDSArray()` constructor always
returns the object with rows being features (genes / variants / snps)
and the columns being "samples". This is consistent with the assay
data inside `SummarizedExperiment`.

```{r, GDSArray}
file <- SeqArray::seqExampleFileName("gds")
GDSArray(file, "genotype/data")
```
A `GDSMatrix` is a 2-dimensional `GDSArray`, and will be returned from
the `GDSArray()` constructor automatically if the input GDS node is
2-dimensional.

```{r, GDSMatrix}
GDSArray(file, "phase/data")
```

The `GDSFile` is a light-weight class to represent GDS files. It has
the `$` completion method to complete any possible gds nodes. It could
be used as a convenient `GDSArray` constructor if the slot of
`current_path` in `GDSFile` object represents a valid gds node.
Otherwise, it will return the `GDSFile` object with an updated
`current_path`.

```{r, GDSFile}
gf <- GDSFile(file)
gf$annotation$info
gf$annotation$info$AC
```
Try typing in `gf$ann` and pressing `tab` key for the auto-completion. 

`gdsfile` function returns the file path of the corresponding GDS
  file.
```{r, gdsfileAccessor}
gdsfile(ga)
```

### seed contract

`GDSArray` follows the seed contract for `DelayedArray` extension, and
  supports the `dim`, `dimnames` methods.
```{r, seedContract}
ga <- GDSArray(file, "genotype/data")
seed(ga)
dim(ga)
dimnames(ga)
```

### methods

`GDSArray` instances can be subset, following the usual _R_
conventions, with numeric or logical vectors; logical vectors are
recycled to the appropriate length.

```{r, methods}
ga[1:3, 10:15]
ga[c(TRUE, FALSE), ]
```

some numeric calculation: 
```{r, numeric}
dp <- GDSArray(file, "annotation/format/DP/data")
dp
log(dp)
dp[rowMeans(dp) < 60, ]
```


**Summary:**

`GDSArray` is a Bioconductor package that represents GDS files as
objects derived from `DelayedArray` class. It converts a GDS node in
the file to a `DelayedArray`-derived data structure. The rich common
methods and data operations defined on `GDSArray` makes it more
R-user-friendly than working with the GDS file directly. 

The array data from GDS files are always returned with the first
dimension being "variants/snps" and the second dimension being
"samples". This feature is consistent with the assay data saved in
`SummarizedExperiment`, and makes the `GDSArray` package easily
interoperable with other established _Bioconductor_ data
infrastructure and methods.



## VCFArray

### Introduction

[VCFArray][] is a _Bioconductor_ package that represents VCF files as
objects derived from the [DelayedArray][] package and `DelayedArray`
class. It converts data entries from VCF file into a `DelayedArray`-derived data structure. The backend VCF file could either be saved on-disk
 locally or remote as online resources. Data entries that could be extracted include
 the fixed data fields (REF, ALT, QUAL, FILTER), information field
 (e.g., AA, AF...), and the individual format field (e.g., GT,
 DP...).    

		       The array data generated from fixed/information
 fields are one-dimensional`VCFArray`, with the dimension being the length of the variants. The
 array data generated from individual `FORMAT` field are always
 returned with the first dimension being `variants` and the second
 dimension being `samples`. This feature is consistent with the assay
 data saved in `SummarizedExperiment`, and makes the `VCFArray`
 package easily interoperable with other established _Bioconductor_
 data infrastructure.
 
 [VCFArray]: https://bioconductor.org/packages/VCFArray

### `vcfFields()`

The `vcfFields()` method takes the character string (VCF file path),
`VcfFile` object or `RangedVcfStack` object as input, and returns a
CharacterList with all available VCF fields within specific
categories. Users should consult the `fixed`, `info` and `geno`
category for available data entries that could be converted into
`VCFArray` instances. The data entry names can be used as input for
the `name` argument in `VCFArray` constructor.

```{r avail, message=FALSE}
args(VCFArray)
fl <- system.file("extdata", "chr22.vcf.gz", package = "VariantAnnotation")
library(VariantAnnotation)
vcfFields(fl)
```

### `VCFArray`, `VCFMatrix` and `vcffile()`

We can construct the `VCFArray` object from the same input as
`vcfFields()` methods (the character string for VCF file path,
`VcfFile` object or `RangedVcfStack` object). 

With a simplest example, we can construct a `VCFArray` object for the
`GT` data entry in the provided VCF file with arguments of `file` and
`name` only.

```{r constructor}
## character string
VCFArray(file = fl, name = "GT")

## "VcfFile"
vcf <- VariantAnnotation::VcfFile(fl)
VCFArray(file = vcf, name = "DS")

## "RangedVcfStack"
extdata <- system.file(package = "GenomicFiles", "extdata")
files <- dir(extdata, pattern="^CEUtrio.*bgz$", full=TRUE)[1:2]
names(files) <- sub(".*_([0-9XY]+).*", "\\1", basename(files))
seqinfo <- as(readRDS(file.path(extdata, "seqinfo.rds")), "Seqinfo")
stack <- GenomicFiles::VcfStack(files, seqinfo)
gr <- as(GenomicFiles::seqinfo(stack)[rownames(stack)], "GRanges")
## RangedVcfStack
rgstack <- GenomicFiles::RangedVcfStack(stack, rowRanges = gr)
rgstack

vcfFields(rgstack)$geno
VCFArray(rgstack, name = "SB")
```

the backend VCF file could also be remote files. Here we included an
example of representing VCF file of chromosome 22 from the 1000
Genomes Project (Phase 3). **NOTE that for a remote VCF file, the
`vindex` argument must be specified.** Since this VCF files is
relatively big, and it takes longer time, we only show the code here
without evaluation.

```{r remote, eval=FALSE}
chr22url <- "ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr22.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz"
chr22url.tbi <- paste0(chr22url, ".tbi")
va <- VCFArray(chr22url, vindex =chr22url.tbi, name = "GT")
```

### `DelayedArray` seed contract

```{r, seedAccessor}
va <- VCFArray(fl, name = "GT")
seed(va)

dim(va)
dimnames(va)
```

### methods
```{r, methods}
vcffile(va)

va[1:3, 1:3]
va[c(TRUE, FALSE), ]

ds <- VCFArray(fl, name = "DS")
log(ds+5)
```


# `DelayedDataFrame` for delayed representation of metadata 
	
## Introduction
As the genetic/genomic data are having increasingly larger profile,
the annotation file are also getting much bigger than expected. the
memory space in _R_ has been an obstable for fast and efficient data
processing, because most available _R_ or _Bioconductor_ packages are
developed based on in-memory data manipulation. 

With the development of [DelayedArray][] in representing on-disk data
structures with different back-end in _R_-user-friendly array data
structure (e.g., [HDF5Array][],[GDSArray][]), the high-throughput
genetic/genomic data are now being able to easily loaded and
manipulated within _R_. However, the annotation files for the samples
and features inside the high-through data are also getting
unexpectedly larger than before. With an ordinary `data.frame` or
`DataFrame`, it is still getting more and more challenging for any
analysis to be done within _R_. 

So we have developed the `DelayedDataFrame`, which uses the familiar
_R/Bioconductor_ paradigm, and at the same time, all data (in the unit
of columns) could be optionally saved on-disk (e.g., in
[DelayedArray][] structure with any back-end). Common operations like
constructing, subsetting, splitting, combining could be done using the
familiar`DataFrame` metaphor. This feature of `DelayedDataFrame` could
enable efficient on-disk reading and processing of the large-scale
annotation files, and use signicantly less memory than in-memory
_R/Bioconductor_ alternatives.

[HDF5]: https://www.hdfgroup.org/solutions/hdf5/
[GDS]: http://corearray.sourceforge.net/
[DelayedArray]: https://bioconductor.org/packages/DelayedArray
[GDSArray]: https://bioconductor.org/packages/GDSArray
[HDF5Array]: https://bioconductor.org/packages/HDF5Array

## DelayedDataFrame class

`DelayedDataFrame` extends the `DataFrame` data structure, with an
additional slot called `lazyIndex`, which saves all the mapping
indexes for each column of the data inside `DelayedDataFrame`. It is
similar to `DataFrame` in terms of construction, subsetting,
splitting, combining, and etc.. The `rownames` setting is consistent
with `DataFrame`. It will not be given automatically, but only by
explicitly specify in the constructor function `DelayedDataFrame(,
row.names=...)` or using the slot setter function `rownames()<-`.

The `DelayedDataFrame` columns supports the [DelayedArray][] (and
direct extensions). Here we use 1-dimensional `GDSArray` objects as
example to show the `DelayedDataFrame` characteristics.


```{r, GDSArray}
file <- SeqArray::seqExampleFileName("gds")
gdsnodes(file)
varid <- GDSArray(file, "annotation/id")
AA <- GDSArray(file, "annotation/info/AA")
```

We use an ordinary character vector and the `GDSArray` objects to
construct a `DelayedDataFrame` object.

```{r, construction}
ddf <- DelayedDataFrame(idx = seq_len(dim(AA)), varid, AA)
```

### `lazyIndex` slot

The `lazyIndex` slot is in `LazyIndex` class, which is defined in the
`DelayedDataFrame` package and extends the `SimpleList` class. The
`listData` slot saves unique indexes for all the columns, and the
`index` slots saves the position of index in `listData` slot for each
column in `DelayedDataFrame` object.  In the above example, with an
initial construction of `DelayedDataFrame` object, the index for each
column will all be NULL, and all 3 columns points the NULL values
which sits in the first position in `listData` slot of `lazyIndex`.

```{r}
lazyIndex(ddf)
lazyIndex(ddf)@listData
lazyIndex(ddf)@index
```

Whenever an operation is done (e.g., subsetting), the `listData` slot
inside the `DelayedDataFrame` stays the same, only the `lazyIndex`
slot will be updated, so that the show method, further statistical
calculation will be applied to the subsetting data set. 

For example, here we subset the `DelayedDataFrame` object `ddf` to
keep only the first 5 rows, and see how the `lazyIndex` works. As
shown in below, after subsetting, the `listData` slot in `ddf1` stays
the same as `ddf`. But the subsetting operation was recorded in the
`lazyIndex` slot, and the slots of `lazyIndex`, `nrows` and `rownames`
(if not NULL) are all updated. So the subsetting operation is kind of
`delayed`.

```{r, lazyIndex}
ddf1 <- ddf[1:20,]
identical(ddf@listData, ddf1@listData)
lazyIndex(ddf1)
nrow(ddf1)
```

Only when direct realization call is invoked, (e.g., `DataFrame()`, or
`as.list()`, the `lazyIndex` will be realized and the object of new
class returned. 

For example, when `DelayedDataFrame` is coerced into a `DataFrame`
object, the `listData` slot will be updated according to the
`lazyIndex` slot.


```{r ddfCoercion}
df1 <- as(ddf1, "DataFrame")
df1@listData
dim(df1)
```

### Methods

`DelayedDataFrame` supports for all methods that are available in
`DataFrame`, including the `[` subsetting, `[[` extraction, `rbind`,
and `cbind` methods, etcs.

```{r ddfMethods}
ddf[, 1, drop=FALSE]  ## integer subscripts
ddf[, "AA", drop=FALSE]  ## character subscripts
ddf[, c(TRUE,FALSE)]  ## logical subscripts

ddf[["AA"]]
ddf[[3]]
```

When doing `rbind`ing, the `lazyIndex` of input arguments will be
realized and a new `DelayedDataFrame` with NULL lazyIndex will be
returned.

```{r ddfRbind}
ddf2 <- ddf[21:40, ]
(ddfrb <- rbind(ddf1, ddf2))
lazyIndex(ddfrb)
```

`cbind`ing of`DelayedDataFrame` objects will keep all existing
`lazyIndex` of input arguments and carry into the new
`DelayedDataFrame` object.

```{r, ddfCbind, error=FALSE}
(ddfcb <- cbind(varid = ddf1[,2, drop=FALSE], AA=ddf1[, 3, drop=FALSE]))
lazyIndex(ddfcb)
```

# `VariantExperiment` container for lazy infrastructures


# examples? use case? 
